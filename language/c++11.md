## C++11 practice with Tango codebase

### auto

#### example

<pre>
boost::unordered_map<std::string, ContactImplPointer> iter = tangoContacts.begin();
</pre>

in r157689 (container_util.h):

<pre>
LET(iter, tangoContacts.begin());
</pre>

in r157671:

<pre>
auto iter = tangoContacts.begin();
</pre>

#### others

* const auto& 

* Range-based for(iterVarDecl: expression) implementation:

<pre>
{
	auto&& rango = expression;
	for(auto b = begin(range), end = end(range); b != e; ++b) {
		iterVarDecl = *b;
		&lt;statements&gt;
	}
}
</pre>

* return type

<pre>
template<class T, class U>
??? mul(T x, U y)
{
  return x*y;
}
</pre>

auto: "return type to be deduced or specified later."
<pre>
template<class T, class U>
auto mul(T x, U y) -> decltype(x*y)
{
  return x*y;
}
</pre>


### raw string

<pre>
	std::string path{ R"(C:\teamwork\new_project\project1)" };

  	std::string cmd{ R"(echo "test" | grep "t")" };

  	std::string expression{ R"([\w]+[ ]+)" };

  	std::string files{ R"( Contact.h
                           Contact.cpp
                           ContactManager.cpp)" };
</pre>

### uniform initialization

Brace initialization syntax now allowed everywhere.

#### example

<pre>
std::set<sgiggle::corefacade::util::PhoneTypeEnum> phoneTypesInOrder;
phoneTypesInOrder.insert(sgiggle::corefacade::util::PHONE_TYPE_IPHONE);
...
if(allow_non_mobile) {
	phoneTypesInOrder.insert(sgiggle::corefacade::util::PHONE_TYPE_MAIN);
	...
}
</pre>

in r157619:

<pre>
std::set<sgiggle::corefacade::util::PhoneTypeEnum> phoneTypesInOrder{sgiggle::corefacade::util::PHONE_TYPE_IPHONE,
    sgiggle::corefacade::util::PHONE_TYPE_MOBILE, sgiggle::corefacade::util::PHONE_TYPE_WORK};
if (allow_non_mobile) {
    phoneTypesInOrder.insert({sgiggle::corefacade::util::PHONE_TYPE_MAIN, sgiggle::corefacade::util::PHONE_TYPE_GENERIC, sgiggle::corefacade::util::PHONE_TYPE_HOME});
}
</pre>

#### others

<pre>
	struct s_t {
  		int a;
  		bool b;
  		std::string s;
	};

	s_t(1, static_cast<bool>(10), "xxx");

	class c_t {
		int a_;
		bool b_;
		std::string s_;
	public:
		c_t(bool b) b(b) {}
	};

	c_t(true);
</pre>

### lambda

#### example

<pre>

#define SEQ_ERASE(iter_ahead, seq, predicate)        \
    {                                                  \
      auto iter_ahead = (seq).begin();                  \
      auto iter_valid = (seq).begin();                  \
      for(; iter_ahead != (seq).end(); ++iter_ahead) { \
        if (!(predicate)) {                            \
          *(iter_valid++) = *iter_ahead;               \
        }                                              \
      }                                                \
      (seq).erase(iter_valid, (seq).end());            \
    }


SEQ_ERASE(iter, *contactUpdatedSucceedList, (!getContactByHash((*iter)) || getContactByHash((*iter))->isNotToBeDisplayed()));

</pre>

in r157689:

<pre>
contactUpdatedSucceedList->erase(std::remove_if(contactUpdatedSucceedList->begin(),
                                                      contactUpdatedSucceedList->end(),
                                                      [=](std::string& hash){
                                                        return !getContactByHash(hash) || getContactByHash(hash)->isNotToBeDisplayed();
                                                      }), contactUpdatedSucceedList->end()); 

</pre>

### concurrency support

* thread
* future
* mutex/condition
* call_once/once_flag

### move

* rvalue reference

- const reference: lvalue, rvalue
- non-const reference: lvalue
- non-const r-reference: std::move or *move* from temporary

### UDT (user defined type)

* default

<pre>
  class Y {
    // ...
    Y& operator=(const Y&) = default; // default copy semantics
    Y(const Y&) = default;
  };
</pre>

* delete

<pre>
  class X {
    // ...
    X& operator=(const X&) = delete;  // Disallow copying
    X(const X&) = delete;
  };
</pre>

* override

<pre>
struct B {
  virtual void f();
  virtual void g() const;
  virtual void h(char);
  void k(); // not virtual
};

struct D : B {
  void f() override;  // OK: overrides B::f()
  void g() override;  // error: wrong type
  virtual void h(char); // overrides B::h(); likely warning
  void k() override;  // error: B::k() is not virtual
};
</pre>

* final

<pre>
struct B {
  virtual void f() const final; // do not override
  virtual void g();
};

struct D : B {
  void f() const;   // error: D::f attempts to override final B::f
  void g();   // OK
};
</pre>

* extern templates

<pre>
#include "MyVector.h"

extern template class MyVector<int>; // Suppresses implicit instantiation below --
                                     // MyVector<int> will be explicitly instantiated elsewhere

void foo(MyVector<int>& v)
{
}

</pre>

<pre>
#include "MyVector.h"

template class MyVector<int>;
</pre>

This is basically a way of avoiding significant redundant work by the compiler and linker.

* default data member (uniform init)
* delegate constructor
* variadic template

* std::array, std::unordered_map/set, std::tuple

* std::function, std::bind

* unique_ptr, shared_ptr, weak_ptr

* GC/ memory model

* time, rand

* thread, mutex, condition, future, promise
