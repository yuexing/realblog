## C++11 practice with Tango codebase

### auto

#### example

<pre>
boost::unordered_map<std::string, ContactImplPointer> iter = tangoContacts.begin();
</pre>

in r157689 (container_util.h):

<pre>
LET(iter, tangoContacts.begin());
</pre>

in r157671:

<pre>
auto iter = tangoContacts.begin();
</pre>

#### others

* const auto& 

* Range-based for(iterVarDecl: expression) implementation:

<pre>
{
	auto&& rango = expression;
	for(auto b = begin(range), end = end(range); b != e; ++b) {
		iterVarDecl = *b;
		<statements>
	}
}
</pre>

### raw string

<pre>
	std::string path{ R"(C:\teamwork\new_project\project1)" };

  	std::string cmd{ R"(echo "test" | grep "t")" };

  	std::string expression{ R"([\w]+[ ]+)" };

  	std::string files{ R"( Contact.h
                           Contact.cpp
                           ContactManager.cpp)" };
</pre>

### uniform initialization

Brace initialization syntax now allowed everywhere.

#### example

<pre>
std::set<sgiggle::corefacade::util::PhoneTypeEnum> phoneTypesInOrder;
phoneTypesInOrder.insert(sgiggle::corefacade::util::PHONE_TYPE_IPHONE);
...
if(allow_non_mobile) {
	phoneTypesInOrder.insert(sgiggle::corefacade::util::PHONE_TYPE_MAIN);
	...
}
</pre>

in r157619:

<pre>
std::set<sgiggle::corefacade::util::PhoneTypeEnum> phoneTypesInOrder{sgiggle::corefacade::util::PHONE_TYPE_IPHONE,
    sgiggle::corefacade::util::PHONE_TYPE_MOBILE, sgiggle::corefacade::util::PHONE_TYPE_WORK};
if (allow_non_mobile) {
    phoneTypesInOrder.insert({sgiggle::corefacade::util::PHONE_TYPE_MAIN, sgiggle::corefacade::util::PHONE_TYPE_GENERIC, sgiggle::corefacade::util::PHONE_TYPE_HOME});
}
</pre>

#### others

<pre>
	struct s_t {
  		int a;
  		bool b;
  		std::string s;
	};

	s_t(1, static_cast<bool>(10), "xxx");

	class c_t {
		int a_;
		bool b_;
		std::string s_;
	public:
		c_t(bool b) b(b) {}
	};

	c_t(true);
</pre>

### lambda

#### example

<pre>

#define SEQ_ERASE(iter_ahead, seq, predicate)        \
    {                                                  \
      auto iter_ahead = (seq).begin();                  \
      auto iter_valid = (seq).begin();                  \
      for(; iter_ahead != (seq).end(); ++iter_ahead) { \
        if (!(predicate)) {                            \
          *(iter_valid++) = *iter_ahead;               \
        }                                              \
      }                                                \
      (seq).erase(iter_valid, (seq).end());            \
    }


SEQ_ERASE(iter, *contactUpdatedSucceedList, (!getContactByHash((*iter)) || getContactByHash((*iter))->isNotToBeDisplayed()));

</pre>

in r157689:

<pre>
contactUpdatedSucceedList->erase(std::remove_if(contactUpdatedSucceedList->begin(),
                                                      contactUpdatedSucceedList->end(),
                                                      [=](std::string& hash){
                                                        return !getContactByHash(hash) || getContactByHash(hash)->isNotToBeDisplayed();
                                                      }), contactUpdatedSucceedList->end()); 

</pre>

### concurrency support

* thread
* future
* mutex/condition
* call_once/once_flag

### move

### UDT (user defined type)

* default
* delete
* default data member (uniform init)
* delegate constructor
